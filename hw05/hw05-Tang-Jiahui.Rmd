---
title: "hw05-Tang-Jiahui"
author: "Jiahui Tang"
date: "2017/10/12"
output: github_document
---

```{r}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(gapminder))
suppressPackageStartupMessages(library(singer))
suppressPackageStartupMessages(library(forcats))
knitr::opts_chunk$set(fig.width=13, fig.height=10)
```

## Factor Management

 I chosen the `Singer`dataframe to explore in this part.
 
### Factorise

*Transform some of the variable in the singer_locations dataframe into factors: pay attention at what levels you introduce and their order. Try and consider the difference between the base R as.factor and the forcats-provided functions.*

- First let's look at this dataset by using`glimpse()`, and we can find that the type of variables are not`factor`. Then I transform three variables,`artisit_name`,`year`and`city`into factors.

```{r}
data("singer_locations")
glimpse(singer_locations)
```

- We can use different ways to transform variables to factors: the base R as.factor and the forcats-provided functions`as_factor`.

- However, when I tried to transform`year<int>`and`city<chr>`, I came across some ERRORS. Since year is numerical, it did not work if I use`as_factor()`directly, I changed it from integer into character first. As for`city`, which is a character variable with NA, we should add a value for NA.

*the base R as.factor*

```{r}
singer_factor_base <- singer_locations %>% 
  mutate(artist_name = as.factor(artist_name),
         year = as.factor(year),
         city = as.factor(city))

str(singer_factor_base$artist_name)
str(singer_factor_base$year)
str(singer_factor_base$city)
```

*the forcats-provided functions`as_factor`*

```{r}
singer_factor <- singer_locations %>% 
  mutate(artist_name = as_factor(artist_name),
         city = ifelse(is.na(city), "NA", city),
         city = as_factor(city),
         year = as_factor(as.character(year)))

str(singer_factor$artist_name)
str(singer_factor$year)
str(singer_factor$city)
```

*From the results above, we can find that`as_factor()`would change the order of factor, while`as.factor`does not. Besides, the`levels`are different because we added some vaules into`city`.*

### Drop 0

*Filter the`singer_locations`data to remove observations associated with the uncorrectly inputed`year`0. Additionally, remove unused factor levels. Provide concrete information on the data before and after removing these rows and levels; address the number of rows and the levels of the affected factors.*

- Filter() was used to remove unexpected observations, and we can find that the number of rows are changed from 10100 to 10000. However, unused levels of artist_name and city were not removed. droplevels() can be exploited to solve this problem. 

```{r}
a = dim(singer_factor)[1]
b = nlevels(singer_factor$year)
c = nlevels(singer_factor$artist_name)
d = nlevels(singer_factor$city)

singer_FB_year <- singer_factor %>% 
  filter(year != 0) %>% 
  mutate(year = as_factor(as.character(year)))

singer_year_dropped <- singer_FB_year %>% 
  droplevels()
e = dim(singer_year_dropped)[1]
f = nlevels(singer_year_dropped$year)
g = nlevels(singer_year_dropped$artist_name)
h = nlevels(singer_year_dropped$city)


mytable <- cbind(before_drop = c(a,b,c,d),after_drop = c(e,f,g,h))
rownames(mytable) <- c("Rows", "year_levels","artist_levels", "city_levels")
knitr::kable(mytable)

```

*The table above shows how the number of rows and levels of factors changed before and after removing. After using`droplevels()`, we now have 7408 and 1309 levels respectively for artist_name and city, which means there are 90 and 8 levels affected.*

### Reorder the levels of`year`, `artist_name` or `title`.

*Use the forcats package to change the order of the factor levels, based on a principled summary of one of the quantitative variables. Consider experimenting with a summary statistic beyond the most basic choice of the median.*

- In this part, fct_reorder() was applied to the factor levels, and we can order`artist_name`and`year` by another quantitative variable`artist_familiarity`.
 + order according to max artist_familiarity
 + backwards
```{r}
fct_reorder(singer_year_dropped$artist_name, singer_year_dropped$artist_familiarity, max) %>% 
  levels() %>%  head()
```

```{r}
## backwards
fct_reorder(singer_year_dropped$year, singer_year_dropped$artist_familiarity,desc = TRUE) %>% 
  levels() %>%  head()
```

### Common part

*Characterize the (derived) data before and after your factor re-leveling.*

## File I/O

*Experiment with one or more of`write_csv()/read_csv()`(and/or`TSV`friends),`saveRDS()/readRDS()`,`dput()/dget()`. Create something new, probably by filtering or grouped-summarization of Singer or Gapminder.*

## Visualization design

*Remake at least one figure or create a new one, in light of something you learned in the recent class meetings about visualization design and color. Maybe juxtapose your first attempt and what you obtained after some time spent working on it. Reflect on the differences.*

## Writing figures to file

*Use`ggsave()`to explicitly save a plot to file. Then use`![Alt text](/path/to/img.png)`to load and embed it in your report.*

## But I want to do more!

*Make a deeper exploration of the forcats packages, i.e. try more of the factor level reordering functions.*
















